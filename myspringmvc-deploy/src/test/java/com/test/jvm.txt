类加载器把类的信息加载到方法区。
方法区（永久区perm）存放类信息，常量信息，方法、常量、字段，常量池信息，包括字符串常量和数字常量的。决定了系统可以放多少个类。如果方法区太小，会方法区溢出。

java堆，存放实例对象所有线程共享。

直接内存，广泛用在nio中；

虚拟机栈，每个线程创建时的方法参数、局部变量、返回值。线程私有的空间，三部分组成，局部变量表、操作数栈和帧数据区。
操作数栈：计算过程的中间结果，变量临时存储空间。

本地方法栈：；

程序计数器：；

垃圾收集器：复制算法、引用计数法(循环引用)、标记清除法(碎片)、标记压缩法；

堆栈方法区关联？
堆存放数据，如何存放；栈执行程序，如何处理数据；方法区是辅助堆栈的永久区（Perm），类信息、静态信息；堆通过方法区的类信息创建对象；

垃圾回收机制：不同的机制有，最常见的是分为新生代和老年代；新生代分为edon区（创建，一次gc后放到s区）、s0与s1区(from与to区，可以相互转换交替位置，一次只有一个使用)
老年代规则：GC垃圾回收X次后还没被回收(-XX：MaxTenuringThreshold 参数配置，默认15次；)，就可以去老年代；eden区创建的对象第一次gc后还存活就会放入s0或s1；tenured。

什么时候gc？虚拟机自己控制，写代码手工调用。new时堆不足时肯定gc。

能配置那些虚拟机参数？
堆栈方法区和垃圾回收机制。
堆：
（堆大小）-Xms初始化堆大小 -Xmx最大堆大小;直接设置初始化大小和最大大小相等。这样减少垃圾回收的次数。
（新生代）-Xmn:设置新生代的大小，一般为堆大小的1/3到1/4左右；
(新生代比例)-XX:suvivorRatio，即eden/from=eden/to，eden=Xmn大小÷（eden/(eden+from+to)）
（新生代年老代比例）-XX:NewRatio=年老代/新生代
-XX:+HeapDumpOnOutOfMemoryError -XX:HeadDumpPath导出堆设置路径
-XX：MaxTenuringThreshold，新生代进入年老代需要经历多少次gc，默认15次；大对象直接进年老代

栈：-Xss 指定线程的最大栈空间，决定了函数可调用的最大深度；
方法区：-XX:MaxPermSize
-XX：+
-XX:+xxGC 串行 并行
-client client（快、对系统优化少，）和server模式（慢、有优化，长期跑比client快），jdk1.7的64位后没有了；

理论算法：引用计数法有循环引用问题；标记清除算法有空间碎片问题；
实际算法：复制算法、标记压缩算法；
新生代（）from和to）复制算法避免空间碎片问题；
老年代标记压缩算法，是对标记清除算法的优化；
新生代对象被gc频繁不稳定，老年代对象比较稳定；
！！分代算法，将内存分为N块根据每个内存的特点使用不同的算法；
新生代回收频率高、耗时短，老年代回收效率低耗时长，尽量减少老年代的gc；
！！分区算法：内存分寸N个独立空间，每个小空间gc而不是整个空间gc；


新生代收集器：Serial、ParNew、Parallel Scavenge；
老年代收集器：Serial Old、Parallel Old、CMS；
整堆收集器：G1；

是JAVA虚拟机在Server模式下的默认值，使用Server模式后，java虚拟机使用Parallel Scavenge收集器（新生代）+ Serial Old收集器（老年代）的收集器组合进行内存回收。

没有gc介入对象一直在eden区，Minor GC即新生代GC，指发生在新生代的垃圾收集动作；Full GC 又称Major GC或老年代GC，指发生在老年代的GC；

垃圾回收的停顿现象：stop the world；



